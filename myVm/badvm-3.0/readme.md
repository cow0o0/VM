# badVm-3.0

此版本是结合了第一版和第二版的改进版本。

一个虚拟机的设计主要考虑三块内容：

1. 指令系统
2. 编译器
3. 解释器

指令系统的设计和第二版是一样的，不过为了叙述的完整性，这里在重复一遍。

## 指令系统

这是基于堆栈的虚拟机

那什么是基于寄存器的虚拟机呢？？？？

表达式：

```
　　Add eax,ecx
　　可以翻译为：
　　Push ecx
　　Push eax
　　Add
　　Pop eax
```
>这只是粗略的理解，不代表之后就是这么设计的。

设计原则，首先将mips指令进行了分解，得到第二层指令，在此基础上将指令进一步的分解，得到第三层指令。第三层指令是原子指令，所有的寄存器，内存，立即数都通过`stack`的`push`，`pop`的方式进行传递。所有的计算在虚拟机的`stack`上进行，这是最后的原子指令的设计原则。设计一个`stack`用来计算，`stack`中不做任何的存储，仅用做存储临时变量。而后根据此指令系统设计相应的编译器，采用二层和三层指令随机结合的方式，也就是说实现同样功能的指令可以有多种组合形式。

原子指令(第三层指令)

```
AtomAdd
AtomSub
AtomAnd
AtomXor
AtomOr 
AtomNor
AtomMul
AtomSll
AtomSra

SetLessThanImm
SetLessThanReg
BranchNotEquelZero
BranchNotEquelReg
BranchIfEquelZero
BranchIfEquelReg

Jmp
Nop

PushImm
PushMem
PushReg
PopImm
PopMem
PopReg
Ret
```

指令系统的设计是整个虚拟机保护中的关键，也是最难的地方。向下直接关系到解释器的实现，向上关系到能否较为完整的翻译目标指令。

>具体参考`指令系统.md`

## 编译器

这里的编译器指的是将mips指令转换为可读结构的工具，通常需要使用到反汇编引擎，自己实现一个反汇编引擎明显是不太现实的一件事情

利用`python`的`capstone`模块

这里的代码可以参考`capstone`的`git`，其中会有各个指令集的参考代码，我就是基于此写的编译器。

针对核心代码进行反汇编。得到可读的结构，然后根据目标指令和虚拟机指令的关系进行映射，我这由于是多层指令的结构因此可以对二层和三层的指令进行随机的结合。

>具体参考`编译器.md`

## 解释器

这里的解释器指的是翻译并执行虚拟机指令的功能模块。

解释器和指令系统结合的比较紧密，这是指令系统的具体编程实现。

主要是数据大小，内存分配，各个结构的大小。我依据的mips的设计模式，其执行方式和mips指令类似，只不过是指令上的分解和替换。

*关于解释器的实现，主要还是多进行调试。*

>具体参考`解释器.md`

## 项目结构

```
	//项目主程序 解释器
	main.c			主函数
	vmhandler.c		提供必要的VM执行框架程序
	vmhandler.h		定义和声明
	vmopcode.c		提供VM各个指令的具体实现
	vmopcode.h		定义和声明
	
	//编译器
	dismips.py		用来反编译mips指令，随机生成虚拟机指令
	
	//构建
	makefile		构建项目的makefile
	
	//演示Demo
	login			用来测试的示例程序
	showDemo.py		用来直观演示虚拟机保护效果的GUi程序
	log.txt			记录反编译的结果需要使用dismips.py > log.txt
	flag			用来测试的flag
	
```

>其实也没什么结构可言，哈哈～

# 用法

这个用法比较复杂，主要是看懂指令系统的设计。而且由于存在许多BUG，因此可能最好的方法还是在理解虚拟机指令的基础上，自己手写一段虚拟机指令代码，不要依赖`dismips.py`所生成的代码，值得依赖的是解释器，如果解释器出现`BUG`，还请提交`Issues`，我会及时修复。

对于main.c的大多数代码需要自己根据自己想要的功能进行实现，此时可以将一部分核心代码使用虚拟机指令进行替换。

可以用来进行`CTF`出题。

![演示](https://github.com/jsk2017/VM/blob/master/myVm/badvm-3.0/out.gif)

>好难解释，相信了解虚拟机保护的师傅，应该很快便能入手，不了解的建议先去看书了解一下，这里可不是新手教程呢。

# 值得改进的地方

非常多。

1. 指令系统没有实现`call`指令
2. 关键部分可以使用汇编进行编写
3. 利用中间语言
3. 自己对CPU理解尚不够深入
4. ...
5. ...

# 深深认识到自己的不足

理论是研究的先行者，由于自己所在的层面还很低，所以根本想不到更深层次的方向，中间语言，编译原理，软件证明，软件测试等。

一点一点朝着方向前进！make！

# 下一版本改进

```
场景需求

有一个已经编译好的MIPS程序

给他进行加密，没有源代码，且保证功能不变。

```

1. 了解VMP软件是如何提供软件保护。
2. 使用中间语言（reil和llvm）对代码进行重构
3. 代码混淆，加壳，反调试

多读书看报，学习之路还很长...

# 总结

此版本的完成也总算是完成了许久之前的一个想法，虽然离真正的虚拟机保护软件相比有太多的不足，不过也算是自己写过的较为完整的项目，希望大学的知识不会白费！共勉！

